;(function (l, u) {
	typeof exports == 'object' && typeof module < 'u'
		? (module.exports = u())
		: typeof define == 'function' && define.amd
		? define(u)
		: ((l = typeof globalThis < 'u' ? globalThis : l || self), (l.EhSvgDrawer = u()))
})(this, function () {
	'use strict'
	var E = Object.defineProperty
	var b = (l, u, s) => (u in l ? E(l, u, { enumerable: !0, configurable: !0, writable: !0, value: s }) : (l[u] = s))
	var y = (l, u, s) => (b(l, typeof u != 'symbol' ? u + '' : u, s), s)
	/**
	 * vivus - JavaScript library to make drawing animation on SVG
	 * @version v0.4.6
	 * @link https://github.com/maxwellito/vivus
	 * @license MIT
	 */ ;(function () {
		function u(t) {
			if (typeof t > 'u') throw new Error('Pathformer [constructor]: "element" parameter is required')
			if (t.constructor === String && ((t = document.getElementById(t)), !t))
				throw new Error('Pathformer [constructor]: "element" parameter is not related to an existing ID')
			if (
				t instanceof window.SVGElement ||
				t instanceof window.SVGGElement ||
				t instanceof window.parent.SVGElement ||
				t instanceof window.parent.SVGGElement ||
				/^svg$/i.test(t.nodeName)
			)
				this.el = t
			else throw new Error('Pathformer [constructor]: "element" parameter must be a string or a SVGelement')
			this.scan(t)
		}
		;(u.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect']),
			(u.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2']),
			(u.prototype.scan = function (t) {
				for (var r, e, i, n, a = t.querySelectorAll(this.TYPES.join(',')), h = 0; h < a.length; h++)
					(e = a[h]),
						(r = this[e.tagName.toLowerCase() + 'ToPath']),
						(i = r(this.parseAttr(e.attributes))),
						(n = this.pathMaker(e, i)),
						e.parentNode.replaceChild(n, e)
			}),
			(u.prototype.lineToPath = function (t) {
				var r = {},
					e = t.x1 || 0,
					i = t.y1 || 0,
					n = t.x2 || 0,
					a = t.y2 || 0
				return (r.d = 'M' + e + ',' + i + 'L' + n + ',' + a), r
			}),
			(u.prototype.rectToPath = function (t) {
				var r = {},
					e = parseFloat(t.x) || 0,
					i = parseFloat(t.y) || 0,
					n = parseFloat(t.width) || 0,
					a = parseFloat(t.height) || 0
				if (t.rx || t.ry) {
					var h = parseInt(t.rx, 10) || -1,
						c = parseInt(t.ry, 10) || -1
					;(h = Math.min(Math.max(h < 0 ? c : h, 0), n / 2)),
						(c = Math.min(Math.max(c < 0 ? h : c, 0), a / 2)),
						(r.d =
							'M ' +
							(e + h) +
							',' +
							i +
							' L ' +
							(e + n - h) +
							',' +
							i +
							' A ' +
							h +
							',' +
							c +
							',0,0,1,' +
							(e + n) +
							',' +
							(i + c) +
							' L ' +
							(e + n) +
							',' +
							(i + a - c) +
							' A ' +
							h +
							',' +
							c +
							',0,0,1,' +
							(e + n - h) +
							',' +
							(i + a) +
							' L ' +
							(e + h) +
							',' +
							(i + a) +
							' A ' +
							h +
							',' +
							c +
							',0,0,1,' +
							e +
							',' +
							(i + a - c) +
							' L ' +
							e +
							',' +
							(i + c) +
							' A ' +
							h +
							',' +
							c +
							',0,0,1,' +
							(e + h) +
							',' +
							i)
				} else
					r.d =
						'M' +
						e +
						' ' +
						i +
						' L' +
						(e + n) +
						' ' +
						i +
						' L' +
						(e + n) +
						' ' +
						(i + a) +
						' L' +
						e +
						' ' +
						(i + a) +
						' Z'
				return r
			}),
			(u.prototype.polylineToPath = function (t) {
				var r = {},
					e = t.points.trim().split(' '),
					i,
					n
				if (t.points.indexOf(',') === -1) {
					var a = []
					for (i = 0; i < e.length; i += 2) a.push(e[i] + ',' + e[i + 1])
					e = a
				}
				for (n = 'M' + e[0], i = 1; i < e.length; i++) e[i].indexOf(',') !== -1 && (n += 'L' + e[i])
				return (r.d = n), r
			}),
			(u.prototype.polygonToPath = function (t) {
				var r = u.prototype.polylineToPath(t)
				return (r.d += 'Z'), r
			}),
			(u.prototype.ellipseToPath = function (t) {
				var r = {},
					e = parseFloat(t.rx) || 0,
					i = parseFloat(t.ry) || 0,
					n = parseFloat(t.cx) || 0,
					a = parseFloat(t.cy) || 0,
					h = n - e,
					c = a,
					d = parseFloat(n) + parseFloat(e),
					p = a
				return (
					(r.d =
						'M' +
						h +
						',' +
						c +
						'A' +
						e +
						',' +
						i +
						' 0,1,1 ' +
						d +
						',' +
						p +
						'A' +
						e +
						',' +
						i +
						' 0,1,1 ' +
						h +
						',' +
						p),
					r
				)
			}),
			(u.prototype.circleToPath = function (t) {
				var r = {},
					e = parseFloat(t.r) || 0,
					i = parseFloat(t.cx) || 0,
					n = parseFloat(t.cy) || 0,
					a = i - e,
					h = n,
					c = parseFloat(i) + parseFloat(e),
					d = n
				return (
					(r.d =
						'M' +
						a +
						',' +
						h +
						'A' +
						e +
						',' +
						e +
						' 0,1,1 ' +
						c +
						',' +
						d +
						'A' +
						e +
						',' +
						e +
						' 0,1,1 ' +
						a +
						',' +
						d),
					r
				)
			}),
			(u.prototype.pathMaker = function (t, r) {
				var e,
					i,
					n = document.createElementNS('http://www.w3.org/2000/svg', 'path')
				for (e = 0; e < t.attributes.length; e++)
					(i = t.attributes[e]), this.ATTR_WATCH.indexOf(i.name) === -1 && n.setAttribute(i.name, i.value)
				for (e in r) n.setAttribute(e, r[e])
				return n
			}),
			(u.prototype.parseAttr = function (t) {
				for (var r, e = {}, i = 0; i < t.length; i++) {
					if (((r = t[i]), this.ATTR_WATCH.indexOf(r.name) !== -1 && r.value.indexOf('%') !== -1))
						throw new Error(
							"Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into 'path' tags. Please use 'viewBox'."
						)
					e[r.name] = r.value
				}
				return e
			})
		var s, g, v, f
		function o(t, r, e) {
			s(),
				(this.isReady = !1),
				this.setElement(t, r),
				this.setOptions(r),
				this.setCallback(e),
				this.isReady && this.init()
		}
		;(o.LINEAR = function (t) {
			return t
		}),
			(o.EASE = function (t) {
				return -Math.cos(t * Math.PI) / 2 + 0.5
			}),
			(o.EASE_OUT = function (t) {
				return 1 - Math.pow(1 - t, 3)
			}),
			(o.EASE_IN = function (t) {
				return Math.pow(t, 3)
			}),
			(o.EASE_OUT_BOUNCE = function (t) {
				var r = -Math.cos(t * (0.5 * Math.PI)) + 1,
					e = Math.pow(r, 1.5),
					i = Math.pow(1 - t, 2),
					n = -Math.abs(Math.cos(e * (2.5 * Math.PI))) + 1
				return 1 - i + n * i
			}),
			(o.prototype.setElement = function (t, r) {
				var e, i
				if (typeof t > 'u') throw new Error('Vivus [constructor]: "element" parameter is required')
				if (t.constructor === String && ((t = document.getElementById(t)), !t))
					throw new Error('Vivus [constructor]: "element" parameter is not related to an existing ID')
				if (((this.parentEl = t), r && r.file)) {
					;(i = this),
						(e = function () {
							var a = document.createElement('div')
							a.innerHTML = this.responseText
							var h = a.querySelector('svg')
							if (!h) throw new Error('Vivus [load]: Cannot find the SVG in the loaded file : ' + r.file)
							;(i.el = h),
								i.el.setAttribute('width', '100%'),
								i.el.setAttribute('height', '100%'),
								i.parentEl.appendChild(i.el),
								(i.isReady = !0),
								i.init(),
								(i = null)
						})
					var n = new window.XMLHttpRequest()
					n.addEventListener('load', e), n.open('GET', r.file), n.send()
					return
				}
				switch (t.constructor) {
					case window.SVGSVGElement:
					case window.SVGElement:
					case window.SVGGElement:
					case window.parent.SVGSVGElement:
					case window.parent.SVGElement:
					case window.parent.SVGGElement:
						;(this.el = t), (this.isReady = !0)
						break
					case window.HTMLObjectElement:
						;(i = this),
							(e = function (a) {
								if (!i.isReady) {
									if (((i.el = t.contentDocument && t.contentDocument.querySelector('svg')), !i.el && a))
										throw new Error('Vivus [constructor]: object loaded does not contain any SVG')
									i.el &&
										(t.getAttribute('built-by-vivus') &&
											(i.parentEl.insertBefore(i.el, t),
											i.parentEl.removeChild(t),
											i.el.setAttribute('width', '100%'),
											i.el.setAttribute('height', '100%')),
										(i.isReady = !0),
										i.init(),
										(i = null))
								}
							}),
							e() || t.addEventListener('load', e)
						break
					default:
						throw new Error('Vivus [constructor]: "element" parameter is not valid (or miss the "file" attribute)')
				}
			}),
			(o.prototype.setOptions = function (t) {
				var r = ['delayed', 'sync', 'async', 'nsync', 'oneByOne', 'scenario', 'scenario-sync'],
					e = ['inViewport', 'manual', 'autostart']
				if (t !== void 0 && t.constructor !== Object)
					throw new Error('Vivus [constructor]: "options" parameter must be an object')
				if (((t = t || {}), t.type && r.indexOf(t.type) === -1))
					throw new Error('Vivus [constructor]: ' + t.type + ' is not an existing animation `type`')
				if (((this.type = t.type || r[0]), t.start && e.indexOf(t.start) === -1))
					throw new Error('Vivus [constructor]: ' + t.start + ' is not an existing `start` option')
				if (
					((this.start = t.start || e[0]),
					(this.isIE =
						window.navigator.userAgent.indexOf('MSIE') !== -1 ||
						window.navigator.userAgent.indexOf('Trident/') !== -1 ||
						window.navigator.userAgent.indexOf('Edge/') !== -1),
					(this.duration = f(t.duration, 120)),
					(this.delay = f(t.delay, null)),
					(this.dashGap = f(t.dashGap, 1)),
					(this.forceRender = t.hasOwnProperty('forceRender') ? !!t.forceRender : this.isIE),
					(this.reverseStack = !!t.reverseStack),
					(this.selfDestroy = !!t.selfDestroy),
					(this.onReady = t.onReady),
					(this.map = []),
					(this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null),
					(this.ignoreInvisible = t.hasOwnProperty('ignoreInvisible') ? !!t.ignoreInvisible : !1),
					(this.animTimingFunction = t.animTimingFunction || o.LINEAR),
					(this.pathTimingFunction = t.pathTimingFunction || o.LINEAR),
					(this.runOnce = t.runOnce),
					this.delay >= this.duration)
				)
					throw new Error('Vivus [constructor]: delay must be shorter than duration')
			}),
			(o.prototype.setCallback = function (t) {
				if (!!t && t.constructor !== Function)
					throw new Error('Vivus [constructor]: "callback" parameter must be a function')
				this.callback = t || function () {}
			}),
			(o.prototype.mapping = function () {
				var t, r, e, i, n, a, h, c, d, p
				for (c = a = h = 0, r = this.el.querySelectorAll('path'), p = !1, t = 0; t < r.length; t++)
					if (((e = r[t]), !this.isInvisible(e))) {
						if (
							((n = { el: e, length: 0, startAt: 0, duration: 0, isResizeSensitive: !1 }),
							e.getAttribute('vector-effect') === 'non-scaling-stroke')
						) {
							var w = e.getBoundingClientRect(),
								m = e.getBBox()
							;(d = Math.max(w.width / m.width, w.height / m.height)), (n.isResizeSensitive = !0), (p = !0)
						} else d = 1
						if (((n.length = Math.ceil(e.getTotalLength() * d)), isNaN(n.length))) {
							window.console &&
								console.warn &&
								console.warn('Vivus [mapping]: cannot retrieve a path element length', e)
							continue
						}
						this.map.push(n),
							(e.style.strokeDasharray = n.length + ' ' + (n.length + this.dashGap * 2)),
							(e.style.strokeDashoffset = n.length + this.dashGap),
							(n.length += this.dashGap),
							(a += n.length),
							this.renderPath(t)
					}
				for (
					p &&
						console.warn(
							'Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.'
						),
						a = a === 0 ? 1 : a,
						this.delay = this.delay === null ? this.duration / 3 : this.delay,
						this.delayUnit = this.delay / (r.length > 1 ? r.length - 1 : 1),
						this.reverseStack && this.map.reverse(),
						t = 0;
					t < this.map.length;
					t++
				) {
					switch (((n = this.map[t]), this.type)) {
						case 'delayed':
							;(n.startAt = this.delayUnit * t), (n.duration = this.duration - this.delay)
							break
						case 'oneByOne':
							;(n.startAt = (h / a) * this.duration), (n.duration = (n.length / a) * this.duration)
							break
						case 'sync':
						case 'async':
						case 'nsync':
							;(n.startAt = 0), (n.duration = this.duration)
							break
						case 'scenario-sync':
							;(e = n.el),
								(i = this.parseAttr(e)),
								(n.startAt = c + (f(i['data-delay'], this.delayUnit) || 0)),
								(n.duration = f(i['data-duration'], this.duration)),
								(c = i['data-async'] !== void 0 ? n.startAt : n.startAt + n.duration),
								(this.frameLength = Math.max(this.frameLength, n.startAt + n.duration))
							break
						case 'scenario':
							;(e = n.el),
								(i = this.parseAttr(e)),
								(n.startAt = f(i['data-start'], this.delayUnit) || 0),
								(n.duration = f(i['data-duration'], this.duration)),
								(this.frameLength = Math.max(this.frameLength, n.startAt + n.duration))
							break
					}
					;(h += n.length), (this.frameLength = this.frameLength || this.duration)
				}
			}),
			(o.prototype.recalc = function () {
				this.mustRecalcScale ||
					(this.mustRecalcScale = g(
						function () {
							this.performLineRecalc()
						}.bind(this)
					))
			}),
			(o.prototype.performLineRecalc = function () {
				for (var t, r, e, i, n, a = 0; a < this.map.length; a++)
					(t = this.map[a]),
						t.isResizeSensitive &&
							((r = t.el),
							(e = r.getBoundingClientRect()),
							(i = r.getBBox()),
							(n = Math.max(e.width / i.width, e.height / i.height)),
							(t.length = Math.ceil(r.getTotalLength() * n)),
							(r.style.strokeDasharray = t.length + ' ' + (t.length + this.dashGap * 2)))
				this.trace(), (this.mustRecalcScale = null)
			}),
			(o.prototype.draw = function () {
				var t = this
				if (((this.currentFrame += this.speed), this.currentFrame <= 0)) this.stop(), this.reset()
				else if (this.currentFrame >= this.frameLength)
					this.stop(), (this.currentFrame = this.frameLength), this.trace(), this.selfDestroy && this.destroy()
				else {
					this.trace(),
						(this.handle = g(function () {
							t.draw()
						}))
					return
				}
				this.callback(this), this.instanceCallback && (this.instanceCallback(this), (this.instanceCallback = null))
			}),
			(o.prototype.trace = function () {
				var t, r, e, i
				for (
					i = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength, t = 0;
					t < this.map.length;
					t++
				)
					(e = this.map[t]),
						(r = (i - e.startAt) / e.duration),
						(r = this.pathTimingFunction(Math.max(0, Math.min(1, r)))),
						e.progress !== r &&
							((e.progress = r), (e.el.style.strokeDashoffset = Math.floor(e.length * (1 - r))), this.renderPath(t))
			}),
			(o.prototype.renderPath = function (t) {
				if (this.forceRender && this.map && this.map[t]) {
					var r = this.map[t],
						e = r.el.cloneNode(!0)
					r.el.parentNode.replaceChild(e, r.el), (r.el = e)
				}
			}),
			(o.prototype.init = function () {
				;(this.frameLength = 0),
					(this.currentFrame = 0),
					(this.map = []),
					new u(this.el),
					this.mapping(),
					this.starter(),
					this.onReady && this.onReady(this)
			}),
			(o.prototype.starter = function () {
				switch (this.start) {
					case 'manual':
						return
					case 'autostart':
						this.play()
						break
					case 'inViewport':
						var t = this
						const r = new IntersectionObserver(
							function (e) {
								if (e[0].intersectionRatio)
									if (t.parentEl.parentElement.classList.contains('is-before')) {
										const n = { attributes: !0 },
											a = (c, d) => {
												c.forEach((p) => {
													p.type === 'attributes' &&
														p.attributeName === 'class' &&
														(t.currentFrame != 0 && t.reset(),
														p.target.classList.contains('is-animated') &&
															(t.play(), d.disconnect(), t.runOnce && r.unobserve(t.parentEl)))
												})
											}
										new MutationObserver(a).observe(t.parentEl.parentElement, n)
									} else t.reset(), t.play(), t.runOnce && r.unobserve(t.parentEl)
							},
							{ root: null }
						)
						r.observe(t.parentEl)
						break
				}
			}),
			(o.prototype.getStatus = function () {
				return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress'
			}),
			(o.prototype.reset = function () {
				return this.setFrameProgress(0)
			}),
			(o.prototype.finish = function () {
				return this.setFrameProgress(1)
			}),
			(o.prototype.setFrameProgress = function (t) {
				return (
					(t = Math.min(1, Math.max(0, t))), (this.currentFrame = Math.round(this.frameLength * t)), this.trace(), this
				)
			}),
			(o.prototype.play = function (t, r) {
				if (((this.instanceCallback = null), t && typeof t == 'function')) (this.instanceCallback = t), (t = null)
				else if (t && typeof t != 'number') throw new Error('Vivus [play]: invalid speed')
				return (
					r && typeof r == 'function' && !this.instanceCallback && (this.instanceCallback = r),
					(this.speed = t || 1),
					this.handle || this.draw(),
					this
				)
			}),
			(o.prototype.stop = function () {
				return this.handle && (v(this.handle), (this.handle = null)), this
			}),
			(o.prototype.destroy = function () {
				this.stop()
				var t, r
				for (t = 0; t < this.map.length; t++)
					(r = this.map[t]),
						(r.el.style.strokeDashoffset = null),
						(r.el.style.strokeDasharray = null),
						this.renderPath(t)
			}),
			(o.prototype.isInvisible = function (t) {
				var r,
					e = t.getAttribute('data-ignore')
				return e !== null
					? e !== 'false'
					: this.ignoreInvisible
					? ((r = t.getBoundingClientRect()), !r.width && !r.height)
					: !1
			}),
			(o.prototype.parseAttr = function (t) {
				var r,
					e = {}
				if (t && t.attributes)
					for (var i = 0; i < t.attributes.length; i++) (r = t.attributes[i]), (e[r.name] = r.value)
				return e
			}),
			(o.prototype.isInViewport = function (t, r) {
				var e = this.scrollY(),
					i = e + this.getViewportH(),
					n = t.getBoundingClientRect(),
					a = n.height,
					h = e + n.top,
					c = h + a
				return (r = r || 0), h + a * r <= i && c >= e
			}),
			(o.prototype.getViewportH = function () {
				var t = this.docElem.clientHeight,
					r = window.innerHeight
				return t < r ? r : t
			}),
			(o.prototype.scrollY = function () {
				return window.pageYOffset || this.docElem.scrollTop
			}),
			(s = function () {
				o.prototype.docElem ||
					((o.prototype.docElem = window.document.documentElement),
					(g = (function () {
						return (
							window.requestAnimationFrame ||
							window.webkitRequestAnimationFrame ||
							window.mozRequestAnimationFrame ||
							window.oRequestAnimationFrame ||
							window.msRequestAnimationFrame ||
							function (t) {
								return window.setTimeout(t, 1e3 / 60)
							}
						)
					})()),
					(v = (function () {
						return (
							window.cancelAnimationFrame ||
							window.webkitCancelAnimationFrame ||
							window.mozCancelAnimationFrame ||
							window.oCancelAnimationFrame ||
							window.msCancelAnimationFrame ||
							function (t) {
								return window.clearTimeout(t)
							}
						)
					})()))
			}),
			(f = function (t, r) {
				var e = parseInt(t, 10)
				return e >= 0 ? e : r
			}),
			typeof define == 'function' && define.amd
				? define([], function () {
						return o
				  })
				: typeof exports == 'object'
				? (module.exports = o)
				: (window.Vivus = o)
	})()
	class l {
		constructor(s) {
			y(this, 'destroy', () => {
				var s
				this.vivus.stop().destroy(),
					(s = this.scrollTrigger) == null || s.kill(),
					(this.scrollTrigger = null),
					(this.vivus = null),
					this.removeEvents()
			})
			;(this.svgEl = s.svgEl),
				(this.vivusOptions = {
					type: s.type,
					start: s.start,
					animTimingFunction: s.start == 'manual' ? Vivus.LINEAR : s.animTimingFunction,
					duration: s.duration,
					selfDestroy: !0,
					onReady: this.onReadyHandler.bind(this),
					runOnce: s.runOnce,
					reverseStack: s.reverseStack,
				}),
				(this.trigger = s.trigger),
				(this.triggerLocation = s.triggerLocation || [0, 100]),
				(this.redrawOnHover = s.redrawOnHover),
				(this.redrawOnClick = s.redrawOnClick),
				(this.drawMode = s.drawMode),
				(this.enableMarkers = s.enableMarkers || !1),
				(this.id = s.id || null),
				(this.isPageIndicator = s.isPageIndicator),
				this.init()
		}
		init() {
			;(this.vivus = new Vivus(this.svgEl, this.vivusOptions)),
				this.vivusOptions.start == 'manual' && this.createScrollStrigger(),
				this.initEvents()
		}
		onReadyHandler() {
			this.svgEl.classList.add('eh-active')
		}
		createScrollStrigger() {
			gsap.registerPlugin(ScrollTrigger),
				(this.scrollTrigger = ScrollTrigger.create({
					trigger: this.trigger,
					start: this.isPageIndicator ? 'top top' : `top ${100 - this.triggerLocation[0]}%`,
					end: this.isPageIndicator ? 'bottom bottom' : `bottom ${100 - this.triggerLocation[1]}%`,
					markers: this.enableMarkers,
					id: this.id,
					onEnter: (s) => {
						this.drawMode == 'down' &&
							((this.vivusOptions.runOnce && this.hasRun) ||
								(this.vivusOptions.runOnce && this.vivus.getStatus() == 'end' && (this.hasRun = !0)))
					},
					onEnterBack: (s) => {
						this.drawMode == 'up' &&
							((this.vivusOptions.runOnce && this.hasRun) || this.svgEl.classList.add('eh-active'))
					},
					onLeave: (s) => {
						this.drawMode == 'up' && this.vivusOptions.runOnce && this.hasRun
					},
					onLeaveBack: (s) => {
						this.drawMode == 'up' &&
							((this.vivusOptions.runOnce && this.hasRun) ||
								(this.vivusOptions.runOnce && this.vivus.getStatus() == 'end' && (this.hasRun = !0),
								this.svgEl.classList.remove('eh-active')))
					},
					onToggle: (s) => {
						this.hasScrolled = !0
					},
					onUpdate: (s) => {
						switch (this.drawMode) {
							case 'downUp':
							default:
								this.vivus.setFrameProgress(s.progress)
								break
							case 'down':
								s.direction === 1 &&
									(this.vivusOptions.runOnce
										? (this.hasRun || this.vivus.setFrameProgress(s.progress),
										  this.vivus.getStatus() == 'end' && (this.hasRun = !0))
										: this.vivus.setFrameProgress(s.progress))
								break
							case 'up':
								s.direction === -1 &&
									(this.vivusOptions.runOnce
										? this.hasRun || this.vivus.setFrameProgress(Math.abs(s.progress - 1))
										: this.vivus.setFrameProgress(Math.abs(s.progress - 1)))
								break
						}
					},
				}))
		}
		redraw() {
			this.vivus.reset(), this.vivus.init()
		}
		onResize() {
			var s
			;(s = this.scrollTrigger) == null || s.refresh()
		}
		initEvents() {
			;(this.redrawHandler = this.redraw.bind(this)),
				(this.onResizeHandler = this.onResize.bind(this)),
				window.addEventListener('resize', this.onResizeHandler)
			const s = 'touchstart' in window ? 'touchstart' : 'mouseenter'
			this.redrawOnHover &&
				this.vivusOptions.start == 'inViewport' &&
				this.svgEl.addEventListener(s, this.redrawHandler),
				this.redrawOnClick &&
					this.vivusOptions.start == 'inViewport' &&
					this.svgEl.addEventListener('click', this.redrawHandler)
		}
		removeEvents() {
			window.removeEventListener('resize', this.onResizeHandler)
			const s = 'touchstart' in window ? 'touchstart' : 'mouseenter'
			this.redrawOnHover &&
				this.vivusOptions.start == 'inViewport' &&
				this.svgEl.removeEventListener(s, this.redrawHandler),
				this.redrawOnClick &&
					this.vivusOptions.start == 'inViewport' &&
					this.svgEl.removeEventListener('click', this.redrawHandler)
		}
	}
	return l
})
